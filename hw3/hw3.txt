Problem 1 ADTs

1. List of strings containing the experiment history for each subject. A List works well because the subjects
can be clearly ordered by their number in experiment and only have the string of their experiment history associated with them.

2. A Set of students (objects) because there is no particular ordering of the students and they all obtained the
same grade. A list of students could also work but the order would need to be determined if wanted. 

3. A map with a string key of student names and a Student object value type map<string, Student>. The string
will allow the student to be identified and any other additional information could be found within their object. 

4. A map of the letter grade earned to a vector of students who obtained that grade map<char, vector<student>>.
This allows for easy access to all students who earned the grade inputed and links the grade to each student efficiently.

Problem 2 LL Recursion

Output: 5 4 3 2 1 is returned
When in is passed in, it points to the Node at the start of the list. After the while loop, out points to the
last Node in the list which contains 5. Calling funcB(in) brings us into a recursive loop until in->next points
to the final node.This occurs when in points to the fourth node and calls funcB(in->next). This returns in 
(which points to the last node) to funcB(in->next)->next = in. This in points to the fourth node, so then the
value of next for the last node gets changed to point at the fourth node instead of NULL. This pattern continues
until the second node points to the first node. The final change occurs from the original call to funcB of 
funcB(in)->next = NULL. funcB(in) had returned the first node whose next value gets changed to NULL, effectively
reversing the contents of the list without ever changing the actual values. 



Problem 3 Runtime

a)  for (int i = 0; i < n; i ++)
	{  
	   if (A[i] == 0) {     			
	      for (int j = 0; j <= i; j++) {
	          if (A[i] == 0) {						
	             for (int k = 0; k <= j; k++) {    
	                 A[i] = 1;   		
	             }								  
	          }
	      }
	   }
	}

	O(n^2)

	Inner operation takes O(1) and inner for loop runs j+1 times, but after j=0 the if statement fails so it only
	executes once for every i value. The second loop only ever calls the third loop one time because after the
	first call, A[i] != 0 anymore. We can take the summation from j=0 to i of O(1) which gives us O(i) for
	middle loop. The outer loop runs n times and always has the potential to call the other loops (if array is
	all 0s) so we can take the summation from i = 0 to n of O(i), resulting in O(n^2).


b) for (int i = 1; i < n; i *= 2)
	{
	   func(i);
	}

	void func(int x) {
	  if (x <= 1) return;
	  func(x-1);
	}

	O(nlogn)

	The recursive function has the form T(n) = O(1) + T(n-1) (O(1) from the complexity of the if statement and 
	O(n-1) from the recursive call) and therefore simplifies to O(n) since it is larger than O(1).
	The function is called log(n) times from the for loop (i *=2) so overall complexity is O(nlogn).

c)  Node *head = new Node;
	Node *curr = head;
	head->data = 0;
	head->next = nullptr;
	for (int i = 1; i < n; i++)
	{
	   curr->next = new Node;
	   curr = curr->next;
	   curr->data = i;
	   curr->next = nullptr;
	}

	for (int i = 1; i <= n; i++) {
	   curr = head;
	   while (curr != nullptr) {
	      if (curr->data % i == 0) {
	         for (int j = 0; j < n; j++) {
	             A[j] ++;
	         }
	      }
	      curr = curr->next;
	   }
	}

	O(n^2logn)

	All the declarations at the start are just O(1) and the first for loop is O(n) since everything inside takes O(1).
	In the second part, the inner for loop executes n^2/i times for every interation of the outer loop since the while
	loop executes n times and the % i restricts the inner loop to execute for every data value that is a multiple of i 
	which is n/i times. By taking the summation from i = 1 to n of this function (n^2/i), we get a harmonic series
	after pulling out the n^2 resulting in O(n^2logn).
	


d)  double *a = new double [3];
	int size = 3;
	for (int i = 0; i < n; i ++) 
	{
	   if (i == size)
	   {  
	       int newsize = 3 * size;
	       double *b = new double [newsize];
	       for (int j = 0; j < size; j++) b[j] = a[j];
	       		delete [] a;
	       a = b;
	       size = newsize;
	   }
	   a[i] = sqrt(i);
	}

	O(n)

	After entering the for loop there are two possible paths, the if statement and the O(1) code that follows it.
	Considering size increases by powers of 3 every time the if statement executes, it will be entered log3(n-1) times
	since i < n (only entered once when n = 9). Since the outer for loop executes n times, this means the if statement
	will not be entered (n - log3(n-1)) times and perform a constant runtime each time->evaluating to O(n). Since the
	inner for loop executes 3^i times when the if statement is triggered, the system run time can be determined by the
	summation from i = 0 to log3(n-1) of 3^i + O(n) and the summation evalues to O(n) which gives us O(n) + O(n) which
	is just O(n)